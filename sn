#!/bin/sh
# author: Nguyen Cong Hai
# created: 2016-08-01
# version: 0.0.8
# description: please read README.md attached
#  change log:
#   v 0.0.8: changing from bash to sh for efficiency and portability -> change array into string (delimited with ' ')
[ -n "$DEBUG" ]  && set -x

# ========================= VARIABLES =========================
# BASEDIR="$(dirname "$0")" # the dir name to be used to find the snippet file
# STEP='var init' # for debugging: print out which step program is in (e.g main loop, variable initialization, etc) 
readonly VAR_PREFIX="_v" # file prefix for variable filetype (_v<VARNAME>.<filetype>)
readonly PARENT_PREFIX="_p" # file prefix for parent metadata (e.g. Par.sh) (_p.<filetype>)
readonly DEFAULT_MAX_LOOPCOUNT=10 # prevent infinite loop
# gbParentsArray="" # array of parent filetypes starting from the input filetype up to and including the found snippet's filetype. This is used to perform transformation operation from the found snippet to the snippet requested by caller
# gbSnipArr='' # array of parent filetypes come across while searching parent tree for the snippet file
# delimgbSnipArr=' '

argSnipName='' # name of the snippet filetype

## temporary holder for filetype (the arg filetype or the parent filetype of the arg filetype, e.g. makefile filetype has its parent as sh):
# lastFiletype='_' # used to guard against infinite loop, must not be empty all the time
# curParentFilename='' # name of file holding parent info about curSnipName
curSnipName=''
# gbSnipArrSize=''
# curSnipArgFileName=''
loopCount=0
# includerFileArray='' # string to hold snippet include files (include files are files that set variables prior to loading the real snip file, e.g. sh/header.arg set COMMENT variable approriately prior to loading _base/header).
parentFileType='' # type of parent file, as read from parent metafile
parentFileContent='' # parent's file content stripped off # and blank lines
transformCmd='' # a command string used to transform text from parent snippet into child snippet (e.g. transforming single $ in sh into $$ in makefile)
# # replaced by curSnipName
# snipToSource='' # the ultimate physical snip file to be sourced, it will be identified via the loop

## ========================= FUNCTIONS =========================
# _V () {
 # purpose: to setup variable for snippet:
 # args external: gbSnipArr # set by the expandSnip function. So some expandSnip function should be run first before running this function

# ========== VALIDATION ==========  
# # not needed (this is used when recursively calling sn from inside sn (e.g. for nesting snippet):
# for i in $gbSnipArr ; do {
 
#  #XXX: cannot use if (eval "[-z ...") -> incorrect result (don't know why yet):
#  eval "if [ -z \"\${$i+x}\" ] ; then echo \"ERROR: variable undefined: $i\" >&2 ; exit 1; fi"
#  # eval "[ -z \"\$${i}\" ]" ; imm_retval=$?
#  eval "if [ -z \"\$$i\" ] ; then echo \"ERROR: variable is empty string: $i\" >&2 ; exit 1; fi"
# } ; done
 
 # ## assert that varNameArray and varValArray are of the same size:
 # if [ ${#varNameArray[@]} -ne ${#varValArray[@]} ] ; then {
 #  printf "$(basename $0):ERROR: arrays not of the same size: varNameArray(${#varNameArray[@]}) -ne varValArray(${#varValArray[@]}):\n
 #  varNameArray: ${varNameArray[@]}
 #  varValArray: ${varValArray[@]}
 #  " >&2 
 #  exit 1
 # } ; fi
 
# ========== FUNCTION INIT ==========  
# STEP='func init'
 # gbSnipArrSize=${#gbSnipArr[@]} # for note on gbSnipArr, see args external note just above
  
# ## set variables if there is a <filetype>/<VARIABLE_NAME>.arg file
# for i in seq 0 ${#varNameArray[@]} ; do {
# curVarName="${varNameArray[$i]}" # current variable name to search for definition file 
# for i in ${@} ; do {
#  curVarName="${i}" # current variable name to search for definition file 
 
 # # not needed
 # ## traverse the parent tree to find a file named <variable-name>.arg:
 # for counter in $(seq 0 $(($gbSnipArrSize-1))) ; do {
 #  curFile="${BASEDIR}/${gbSnipArr[$counter]}/${curVarName}.arg"   # current filename to process
 #  test -f "${curFile}" && eval "${curVarName}=\"$(cat "${curFile}")\"" && break
 # } ; done
 
# variables not set by the curFile loop above should be set by default values in _base (via the _base/<var-name>.arg file)
## set variable if not set by the curFile loop above:
 # curVarValue="${varValArray[$i]}"
 # eval "test -z \${${curVarName}+x} &&  ${curVarName}=\"${varValArray[$i]}\""
# } ;done
# for i in ${@} ; do eval "echo $i=\$${i}" ; done
# } # setVars

quitErr () {
 # perform some steps prior to quit with error:
  # echo "sn: $*. Filetypes so far: ${gbSnipArr}" >&2
  echo "sn: $*" >&2
  exit 1
} # quitErr

# ========================= MAIN =========================

## if no args given:
[ $# -eq 0 ] && quitErr "pls read README.md"

# ## ensure that 'set-variable' function has been defined before the following code:
# if ! (type -t _V | grep -q 'function') ; then {
#  echo "ERROR: function _V has not been loaded before this functionis called."
#  exit 2
# } ; fi

if [ "${1}" = '-C' ] ; then
 if [ -n "$(readlink -e "${2}")" ] ; then
     cd "${2}" || quitErr "failed entering ${2}"
     shift 2
 else
  quitErr "flag -C: it has arg not pointing to valid dir: ${2}"
 fi
fi

## changding dir to $BASE_DIR:
# oldDir="$(readlink -e .)"
 
## parsing argument:
# assume all flags have been stripped, so arg 1 is operand:
argSnipName="$(readlink -f "${1}")" ; shift 1 
curSnipName="${argSnipName}"
loopCount=0
while true ; do {
 ## check loop conditions:
 if [ "$loopCount" -gt "$DEFAULT_MAX_LOOPCOUNT" ] ; then
     # this means maximum number of looping into parent dirs has reached:
     quitErr "maximum loop reached while finding snippet file ${curSnipName}"
 fi

 loopCount=$((loopCount+1))
# lastFiletype="${curFiletype}"

 ## base case: if found snippet right away: execute it and quit:
 if [ -n "$(readlink -e "${curSnipName}")" ] ; then
     break
 else ## otherwise: move up to parent snippet:
  ## prepare to go to parent snippet:
  ## get filetye of current snippet:
  curFiletype="$(echo "${curSnipName}" | sed -e 's/^.*\.\([^.]\+\)$/\1/')"
  # if current snippet has no filetype (its name has no '.<filetype>' extension) -> assume it is base filetype, which should have been caught  by the if clause just above this:
  if [ "${curFiletype}" = "${curSnipName}" ] ; then
      # if current file has no extension (i.e. its filetype is base, it should have been caught by the condition above
      quitErr "snippet filetype not found: ${curSnipName}"
  else
   parentMetaFile="${PARENT_PREFIX}.${curFiletype}"
   snipBaseName="$(echo "${curSnipName}" | sed -e 's/\.[^.]\+$//')"
   if [ ! -f "${parentMetaFile}" ] ; then
       # if there is snipbasesame file -> it should be of type 'base' -> use it:
       if [ -f "${snipBaseName}" ] ; then
           curSnipName="${snipBaseName}" # update curSnipName to get it sourced after the loop
           break
       else
        quitErr "no parent filename ${parentMetaFile} for this filetype: ${curFiletype}"
       fi
   fi
  fi
 fi

 parentFileContent="$(grep -Ev '^[ \t]*#' "${parentMetaFile}" | sed '/^$/d')" || quitErr "ERROR: failed parsing parent file: ${parentFilename}"
 # if .parent file has no content or failed to read its content:
 if [ -z "$parentFileContent" ] ; then
     quitErr "variable empty: parentFileContent"
 fi

 parentFileType="$(echo "${parentFileContent}" | head -1)"
 curSnipName="${snipBaseName}.${parentFileType}"
 case "$(echo "${parentFileContent}" | wc -l)" in
  1) true ;;
  2) 
   curTransformCmd="$(echo "${parentFileContent}" | tail -1)" || quitErr "ERROR: failed parsing 2nd line of variable parentFileContent: ${parentFileContent}"
   if [ -z "$curTransformCmd" ] ; then
       quitErr "ERROR: curTransformCmd variable empty"
   fi
   if [ -z "$transformCmd" ] ; then
    transformCmd="${curTransformCmd}"
   else
    transformCmd="${transformCmd} | ${curTransformCmd}"
   fi
   ;;
  *) quitErr "parent file content malformed: expected 2 lines" ;;
 esac
 continue
} ; done

if [ ! -f "${curSnipName}" ] ; then
    echo "ERR: snippet file not found. final file: ${curSnipName}" >&2
    exit 1
else
 if [ -z "$transformCmd" ] ; then
     eval ". ${curSnipName}"
 else
  eval ". ${curSnipName} | ${transformCmd}"
 fi
 exit
fi
