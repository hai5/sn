#!/bin/sh
# author: Nguyen Cong Hai
# created: 2016-08-01
# version: 0.1.0
# description: please read README.md attached
#  change log:
#   v 0.0.8: changing from bash to sh for efficiency and portability -> change array into string (delimited with ' ')
# [ -n "$DEBUG" ]  && set -x

# ========================= VARIABLES =========================
SNIPDIR='' # the dir name to be used to find the snippet file
# STEP='var init' # for debugging: print out which step program is in (e.g main loop, variable initialization, etc) 
FILETYPE='' # filetype of the initial snippet being requested as arg. Used in expanding base- filetype variable to know which filetype it is expanding the variable to.
# readonly VAR_PREFIX="_v" # file prefix for variable filetype (_v<VARNAME>.<filetype>)
readonly PARENT_PREFIX="_p" # file prefix for parent metadata (e.g. Par.sh) (_p.<filetype>)
readonly DEFAULT_MAX_LOOPCOUNT=10 # prevent infinite loop
# gbParentsArray="" # array of parent filetypes starting from the input filetype up to and including the found snippet's filetype. This is used to perform transformation operation from the found snippet to the snippet requested by caller
# gbSnipArr='' # array of parent filetypes come across while searching parent tree for the snippet file
# delimgbSnipArr=' '

# argSnipName='' # name of the snippet filetype

## temporary holder for filetype (the arg filetype or the parent filetype of the arg filetype, e.g. makefile filetype has its parent as sh):
# lastFiletype='_' # used to guard against infinite loop, must not be empty all the time
# curParentFilename='' # name of file holding parent info about curSnipName
curSnipName=''
# gbSnipArrSize=''
# curSnipArgFileName=''
loopCount=0
# includerFileArray='' # string to hold snippet include files (include files are files that set variables prior to loading the real snip file, e.g. sh/header.arg set COMMENT variable approriately prior to loading _base/header).
parentFileType='' # type of parent file, as read from parent metafile
parentFileContent='' # parent's file content stripped off # and blank lines
transformCmd='' # a command string used to transform text from parent snippet into child snippet (e.g. transforming single $ in sh into $$ in makefile)
# # replaced by curSnipName
# snipToSource='' # the ultimate physical snip file to be sourced, it will be identified via the loop

# ========== FUNCTION INIT ==========  
# STEP='func init'
 # gbSnipArrSize=${#gbSnipArr[@]} # for note on gbSnipArr, see args external note just above
  
# ## set variables if there is a <filetype>/<VARIABLE_NAME>.arg file
# for i in seq 0 ${#varNameArray[@]} ; do {
# curVarName="${varNameArray[$i]}" # current variable name to search for definition file 
# for i in ${@} ; do {
#  curVarName="${i}" # current variable name to search for definition file 
 
 # # not needed
 # ## traverse the parent tree to find a file named <variable-name>.arg:
 # for counter in $(seq 0 $(($gbSnipArrSize-1))) ; do {
 #  curFile="${SNIPDIR}/${gbSnipArr[$counter]}/${curVarName}.arg"   # current filename to process
 #  test -f "${curFile}" && eval "${curVarName}=\"$(cat "${curFile}")\"" && break
 # } ; done

# variables not set by the curFile loop above should be set by default values in _base (via the _base/<var-name>.arg file)
## set variable if not set by the curFile loop above:
 # curVarValue="${varValArray[$i]}"
 # eval "test -z \${${curVarName}+x} &&  ${curVarName}=\"${varValArray[$i]}\""
# } ;done
# for i in ${@} ; do eval "echo $i=\$${i}" ; done
# } # setVars

quitErr () {
 # perform some steps prior to quit with error:
 # echo "sn: $*. Filetypes so far: ${gbSnipArr}" >&2
 echo "sn: $*" >&2
 exit 1
} # quitErr

_v () {
 # purpose: to setup variable for snippet:
 # each variable's value is stored in a seperate file
 # this function is called when a snippet has been found
 # args external: gbSnipArr # set by the expandSnip function. So some expandSnip function should be run first before running this function
 local thevarname varFileName varFileExt
 
 thevarname="${1}_${FILETYPE}"
 
 ## if variable already defined in environment, use it:
 eval "test -n \"\${${thevarname}+x}\"" \
  && echo "${thevarname}" \
  && return
  
  if [ -z "$FILETYPE" ] ; then
   varFileExt=''
   else
   varFileExt=".${FILETYPE}"
   fi
 # recursively call sn to expand the file _v<varname>.<filetype>:
  varFileName="${SNIPDIR}/v${1}${varFileExt}"
  eval "${thevarname}=\"\$($0 \"${varFileName}\" 2>&1 )\""
  eval "printf \"\${${thevarname}}\""
} # _v 

# ========================= MAIN =========================

## if no args given:
[ $# -eq 0 ] && quitErr "pls read README.md"

[ "$1" = "--debug" ] && shift 1 && set -x

## parsing argument:
# assume all flags have been stripped, so arg 1 is operand:
# argSnipName="$(readlink -f "${1}")" ; shift 1 
SNIPDIR="$(dirname "${1}")"
curSnipName="${SNIPDIR}/$(basename "${1}")"
loopCount=0
while true ; do {
 ## check loop conditions:
 if [ "$loopCount" -gt "$DEFAULT_MAX_LOOPCOUNT" ] ; then
     # this means maximum number of looping into parent dirs has reached:
     quitErr "maximum loop reached while finding snippet file ${curSnipName}"
 fi

 loopCount=$((loopCount+1))
 # lastFiletype="${curFiletype}"

 ## base case: if found snippet right away: execute it and quit:
 if [ -f "${curSnipName}" ] ; then
     break
 else ## otherwise: move up to parent snippet:
  ## prepare to go to parent snippet:
  ## get filetye of current snippet:
  curFiletype="$(echo "${curSnipName}" | sed -e 's/^.*\.\([^.]\+\)$/\1/')" || quitErr "failed parsing filetype from ${curSnipName}"
  test -z "$FILETYPE" && FILETYPE="${curFiletype}"
  # [ -z "$FILETYPE" ] && readonly FILETYPE="${curFiletype}"
  # if current snippet has no filetype (its name has no '.<filetype>' extension) -> assume it is base filetype, which should have been caught  by the if clause just above this:
  if [ "${curFiletype}" = "${curSnipName}" ] ; then
      # if current file has no extension (i.e. its filetype is base, it should have been caught by the condition above
      quitErr "snippet filetype not found: ${curSnipName}"
  else
   parentMetaFile="${PARENT_PREFIX}.${curFiletype}"
   snipBaseName="$(echo "${curSnipName}" | sed -e 's/\.[^.]\+$//')"
   if [ ! -f "${parentMetaFile}" ] ; then
       # if there is snipbasesame file -> it should be of type 'base' -> use it:
       if [ -f "${snipBaseName}" ] ; then
           curSnipName="${snipBaseName}" # update curSnipName to get it sourced after the loop
           break
       else
        quitErr "start snip=${1}, current snip=${curSnipName}: files not found: ${curSnipName} or ${parentMetaFile}"
       fi
   fi
  fi
 fi

 parentFileContent="$(grep -Ev '^[ \t]*#' "${parentMetaFile}" | sed '/^$/d')" || quitErr "ERROR: failed parsing parent file: ${parentFilename}"
 # if .parent file has no content or failed to read its content:
 parentFileType="$(echo "${parentFileContent}" | head -1)"
 curSnipName="${snipBaseName}.${parentFileType}"
 case "$(echo "${parentFileContent}" | wc -l)" in
  1) true ;;
  2) 
   curTransformCmd=" | $(echo "${parentFileContent}" | tail -1)" || quitErr "ERROR: failed parsing 2nd line of variable parentFileContent: ${parentFileContent}"
   # check for null var:
   for i in parentFileType parentFileContent curTransformCmd ; do
    eval "test -z \"\$$i\"" && quitErr "main loop ops: variable empty: $i"
   done
   transformCmd="${transformCmd} ${curTransformCmd}"
   ;;
  *) quitErr "parent file content malformed: expected 2 lines" ;;
 esac
 continue
} ; done

test -f "${curSnipName}" \
 || quitErr " snippet file not found. final file: ${curSnipName}"
 
 eval ". ${curSnipName}${transformCmd}"
 
